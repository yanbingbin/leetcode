## 题目地址

https://leetcode-cn.com/problems/max-area-of-island/

## 题目描述

难度：中等


给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)


### 示例1：

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```
 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

### 示例2：

```
[[0,0,0,0,0,0,0,0]]
```
对于上面这个给定的矩阵, 返回 0。


## 解题方法

- 基础的i，j两层循环数组，每次碰到 1 就开始dfs
- 因为题目假设二维矩阵的四个边缘都被水包围着，所以边界上一定是0，所以当这五种条件下都返回0
- if(i<0 || i>=x || j<0 || j>=y || grid[i][j]==0) return 0
- 如果grid[i][j]==1那么，先将本次访问节点grid[i][j]置零，表示本节点已经被访问过
- dfs遍历其上下左右四个节点
注意：
1. 为了避免重复计数，访问过的点置零即可
2. dfs的每一层返回的是本身计数 1 + 上下左右 的dfs返回值

```js

var maxAreaOfIsland = function(grid) {
    let res = 0;
    const dfs = (i, j) => {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1) {
            return 0
        }
        let count = 1;
        grid[i][j] = 0; 
        count += dfs(i - 1, j);
        count += dfs(i + 1, j);
        count += dfs(i, j - 1);
        count += dfs(i, j + 1);
        return count;
    }
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[row].length; col++) {
            if (grid[row][col] === 1) {
                res = Math.max(res, dfs(row, col))
            }
        }
    }
    return res;
};
```

## 更优解


```js

```

