## 题目地址

https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/

## 题目描述

难度：中等

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

### 示例1：

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

## 暴力法

- 双重循环A和B
- 在找到A[i]等于B[j]的时候，继续比较A[i]和B[j]的下一个元素
- 如果下一个元素相等，继续比较，直到下一个元素不相等或者越界
- 将相同的子串长度保存起来并和之前保存的比较去最大的
- 返回结果

时间复杂度：O(n ^ 3)

```js
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function(A, B) {
    const aLen = A.length;
    const bLen = B.length;
    let res = 0;

    for (let i = 0; i < aLen; i++) {
        for (let j = 0; j < bLen; j++) {
            if (A[i] === B[j]) { // 遇到相同项
                let subLen = 1; // 公共子序列长度
                while(
                    A[i + subLen] === B[j + subLen] && // 下一项也相同
                    i + subLen < aLen && // 没有越界
                    j + subLen < bLen
                ) {
                    subLen++; // 考察下一项
                }
                res = Math.max(subLen, res);
            }
        }
    }
    return res;
};
```

## 滑动窗口

- 先将A固定，移动B，求出公共子数组的长度
- 再将B固定，移动A，求出公共子数组的长度
- 综合比较最长的长度

```
A固定，移动B：

第一步
        A: [1,2,3,2,1]
        B: [3,2,1,4,7]

第二步
        A: [1,2,3,2,1]
      B: [3,2,1,4,7]

第三步
        A: [1,2,3,2,1]
    B: [3,2,1,4,7]

第四步
        A: [1,2,3,2,1]
  B: [3,2,1,4,7]

第五步
        A: [1,2,3,2,1]
B: [3,2,1,4,7]

固定B,移动A：

第一步
    A: [1,2,3,2,1]
    B: [3,2,1,4,7]

第二步
    A: [1,2,3,2,1]
    B: [3,2,1,4,7]

第三步
    A: [1,2,3,2,1]
    B: [3,2,1,4,7]

第四步
    A: [1,2,3,2,1]
    B: [3,2,1,4,7]

第五步
    A: [1,2,3,2,1]
    B: [3,2,1,4,7]
```

```js
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var findLength = function(A, B) {
    const aLen = A.length;
    const bLen = B.length;
    let res = 0;
    // 窗口左端对应A的位置是aStart，窗口左端对应B的位置是bStart
    const getMaxLen = (aStart, bStart, windowLen) => {
        let res = 0;
        let subLen = 0;
        for (let i = 0; i < windowLen; i++) { // 遍历的范围是窗口的长度
            if (
                A[aStart + i] !== undefined &&
                B[bStart + i] !== undefined && 
                A[aStart + i] === B[bStart + i]
            ) {
                subLen++
            } else {
                subLen = 0; // 窗口不满足要求
            }
            res = Math.max(res, subLen);
        }
        return res;
    }

    for (let i = 0; i <= aLen; i++) { // A固定，移动B
       const len = Math.min(aLen, bLen - i); // 当前窗口长度
       const maxLen = getMaxLen(0, i, len); // 窗口左端是A[0]，B[i]
       res = Math.max(res, maxLen);
    }
    for (let i = 0; i <= bLen; i++) { // B固定，移动A
        const len = Math.min(bLen, aLen - i);
        const maxLen = getMaxLen(i, 0, len); // 窗口左端是A[0]，B[i]
        res = Math.max(res, maxLen);
    }
    
    return res;
};
```

