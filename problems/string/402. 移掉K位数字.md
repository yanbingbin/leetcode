## 题目地址

https://leetcode-cn.com/problems/remove-k-digits/

## 题目描述

难度：中等

给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:

num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。

### 示例1：

```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```

### 示例2：

```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

### 示例3：

```
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

## 解题方法

- 从左至右扫描，当前的数还不确定要不要删，先入栈暂存，保留对它的记忆。
- 123531这样「高位递增」的数，会尽量删低位，不会删递增的高位。
- 432135这样「高位递减」的数，肯定想干掉高位，让高位变小，尽量变成「高位递增」
- 所以，如果当前数比栈顶更大，就还是递增态，是满意的，入栈。
- 如果当前数比栈顶更小，要当机立断删栈顶的数，不管后面有没有更大的，为什么？
- 因为栈顶的数在高位，删掉它，后面小的顶上，高位变小，优于低位变小。

```js
var removeKdigits = function (num, k) {
    const stack = [];
    for (let i = 0; i < num.length; i++) {
        if (k <= 0) break; // 不能删除元素了，直接跳出循环
        const char = num[i]; // 要对比的当前字符
        while (k > 0 && stack.length && char < stack[stack.length - 1]) { // 如果还能删除元素且当前元素小于栈顶元素
            stack.pop(); // 将栈顶元素出栈
            k--; // 可删除的元素少1
        }
        if (char !== '0' || stack.length) { // 控制栈顶元素不能为0，避免生成066这种数字
            stack.push(char);
        }
    }
    while (k > 0) { // 循环完还没删除完，将栈顶元素依次出栈
        stack.pop();
        k--;
    }
    return !stack.length ? '0' : stack.join(''); // 拿到结果
};
```