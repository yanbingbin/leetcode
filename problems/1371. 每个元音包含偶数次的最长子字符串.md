## 题目地址

https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/

## 题目描述

难度：中等

给你一个字符串 `s` ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 `'a'，'e'，'i'，'o'，'u'` ，在子字符串中都恰好出现了偶数次。

### 示例1：

```
输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
```

### 示例2：

```
输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
```

### 示例3：

```
输入：s = "bcbcbc"
输出：6
解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
```

### 提示

- 1 <= s.length <= 5 x 10^5
- s 只包含小写英文字母。

## 解题思路

emmm，没有思路，瞅瞅大佬们怎么做的。

### 引入前缀和，将双变量转换成单变量

- [i, j]区间确定一个子串，满足区间内出现的元音为偶数
- 引入前缀和，转成 [0, j]的元音次数 - [0, i - 1]对应的元音次数 = 偶数
- 求 [0, x]的元音次数，这样变量就变成一个了

### 只关心元音出现的次数是否偶数

- 奇数 - 奇数 = 偶数；偶数 - 偶数 = 偶数；一个偶数一个奇数之差一定是奇数
- 转化为：[0, j]出现的元音次数的奇偶性等同于[0, i - 1]对应的元音次数的奇偶性
- 0也算做偶

### 奇偶状态抽象成01

- 用0表示偶数， 1表示奇数
- [0, x]的 u o i e a 各自出现的奇偶次数，都用 0/1 表示，组成一个 5 位二进制数。譬如，00001，代表其中 u o i e 都出现偶次（包括0），a 出现奇次
- 把这个00001当做[0, x]区间内的state，它包含了该区间内5个元音出现次数的奇偶信息

### 条件等价转换

- [0, j]的state和[0, i - 1]的state相同，即两个二进制相等
- 遍历字符串，不断求[0, x]的state，看看哪些state相同，找出满足state相同的最大区间距离

### 求前缀区间的state

- 假设 [0,2][0,2] 的 state 是 00110 ，代表出现 e 和 i 奇数次，假如下一字符是 ii，则 [0,3][0,3] 区间出现的 ii 次数变为偶数， state 为 00010
- 遇到 ii ，从 00110 变到 00010 ，第三位从 1 翻转为 0，其他位不变
- 使特定的位翻转 正是 异或 的作用，第三位翻转，就是异或了 00100
- 异或 相当于 不带进位的二进制加法，所以有 00110 ^ 00100 = 00010
- 元音字母 u o i e a ，分别对应了：10000、01000、00100 ……
- 所以，当前前缀区间的 state 等于 前一个求出 state 异或 当前字符对应的二进制数。好比累乘、累加，只是这是 累异或

### 预置 -1 的情况，使通式普遍适用

- [i,j] 的 u o i e a 出现偶次 <=> [0, j] 的 state 相同于 [0, i - 1] 的 state
- i 显然可以为 0 ，则 i-1i−1 为 -1 ，特别地，我们让 [0, -1] 的 state 是 00000 ，表示在字符串 -1 的位置，所有元音都出现 0 次（偶数）
- 为了让边界情况也能套用通式，即 i = 0时，[0, j] 的元音都出现 偶次 <=> [0, j] 的 state 等于 00000，通式成立！

### 存储前缀区间的state

- 可以选择存到 数组 里，数组的索引和字符位置一一对应
- 也可以用 哈希Map，存键值对: key: state值；value: 对应在字符串中的位置
- 选择 Map ，将逐个求出的 [0, x] 的 state 存入 Map
- 为了书写方便，转成十进制，00110 就存 6 ，是等价的

### 寻找满足条件的state

- 遍历过程中，边存 state ，要边在 Map 中查找
- 看看有没有 之前存过的，与当前 state 相同的 state
- 如果有，则可能不止一个，要根据 value 值，求出它离当前位置的距离，找出有着最长距离的那个，就是我们想要的最大子串长度

### 代码思路

- 准备工作
1. vowel 表，对照表，一个元音对应一个二进制数
2. Map 对象，初始放入 0: -1 键值对，代表 [0, −1] 对应的 state 为 00000 ，即十进制 0
3. state 变量，保存当前前缀区间的 state ，初始值 0
- 遍历字符串，如果当前字符是元音，在 vowel 表获取对应的二进制数，异或 上一次求出的 state ，求出当前的 state
- 不断往 Map 存入 state
- 边存边查看，和当前 state 相等的，之前存过的 state 的 位置
- 求出它与当前位置的距离，这个距离代表 满足条件的子串的长度
- 在 遍历的过程 中，让这个距离 不断挑战 res ，如果比 res 大就更新 res
- 返回res

## 实现代码

时间复杂度：O(n)。 空间复杂度：O(常数)

```js
/**
 * @param {string} s
 * @return {number}
 */
var findTheLongestSubstring = function(s) {
    let res = 0;
    let state = 0; // 前缀区间state状态
    let vowel = { a: 1, e: 2, i: 4, o: 8, u: 16 }; // 二进制对照表
    let map = { 0: -1 }; // 存放哥哥前缀区间的state

    for (let i = 0; i < s.length; i++) {
        let char = s[i];
        if (vowel[char] !== undefined) {
            state ^= vowel[char]; // 异或求出当前前缀区间的state
            if (map[state] === undefined) { // 当前state没存过
                map[state] = i;
            }
        }
        let distance = i - map[state]; // 求距离，满足条件的子串长度
        res = Math.max(res, distance);
    }
    return res;
};
```